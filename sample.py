# リスト型=配列
l = [1, 20, 30, 40, 5, 8, 90]

print(l[0])
# 後ろから取ってくることもできる
list = l[-1]
# 2番目から5番目まで(2,3,4)
print(l[2:5])
# 省略できる [:2]0から2番目まで、[2:]2番目から最後まで
# [::2]ふたつ飛ばしで取得、[::-1]後ろから取得

# リストの操作
# 指定して代入できる。
l[0] = 'x'
l[2:5] = ['c', 'd', 'e']

#空の配列を入れたい場合は、[]を代入するだけ。全部をからにする場合は[:] = []
#append=一番最後に値を追加
#insert(要素数、値)で位代入できる
#pop＝取り出して削除
#del=存在こと削除してしまう
#remove=指定した値を消すことができるremove('x')

#配列を結合するとき a += b
#a.extend(b)というメソッドでも結合できる。

r = [1, 2, 3, 4, 5, 6, 7, 8, 9, 3]
#index(3)だと、インデックス番号を探してくれる。
print(r.index(3,3))
#カンマをつけると、一つ目の数字のインデックス番号移行を検索
#count=要素数を数える

#配列に5は存在するか？
if 5 in r:
    print('exist')
    
#並び替え、reverse=Trueを入れると逆順
r.sort()
r.sort(reverse=True)
#もう一度reverseすると元に戻る
r.reverse()
print(r)

#文字を単語ごとに要素分けして配列に入れる場合
s = 'My name is Mike.'
to_split = s.split('!!')#空白を入れて、要素わけする。存在しない文字列にした場合と全てを一つの要素として配列にしてしまう。
#空白はバリューエラー
print(to_split)

#joinは代入して結合する
x = ' a '.join(to_split)
print(x)

i = [1,2,3]
j = i
j[0] = 100
#この場合、iも入れ替わってしまう。
#なぜ？メモリーに保存してるiのアドレスをjに入れているから（参照渡し）
#リストやディクショナリーは参照渡し、数値などは値わたしなのでコピーする必要はない。

#どう避けるか？コピーを使う。
j = i.copy()
#または[:]を使っても同じことができる。可読性を考慮するとコピーを使った方が良い。

#リストの使い所
#乗客が乗降するタクシー、5人までしか乗れない
seat = []
min = 0
max = 5
check = min <= len(seat) < max
#一人のる
seat.append('p')
print(seat)
print(check)
#一人降りる
seat.pop(0)

#要素数が変動するものに対して論理和などでチェックするという使い方・

#タプル型 ()の中にある配列
t = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
#リストとタプルの違いは？
#リストはブランケットの鉤括弧[]
#タプルはパレンティスの丸括弧()
#タプルはt[0] = 100 などの代入ができない
#使用する場面、ケースとしては、値を代入したら後から変更されたくない、読み込み専用とするときに使われる場合が多い。

#indexなどの読み込み操作などはできる。t[0] = [1]のような代入はできない
#help(tuple)でみるとわかる。
t.index(1)

#タプルは,をつけた時点でタプルになる。t, でもタプルになる。バグの原因になりやすい。
#t=(1)とするとintegerになってしまう。t = (1,)としなければならない。（一つだけのタプルはあまりない）
#タプルにネストしたリストを入れることはできる。
t2 = ([1, 2, 3], [4, 5, 6])

#タプル同士は足すことができる。
new_tuple = (1, 2, 3) + (4, 5, 6)

#タプルのアンパッキング
num_tuple = (10, 20)
print(num_tuple)#(10, 20)

x, y = num_tuple#カンマで区切れば、アンパッキングできる
print(x, y)#10,20

x, y = 10, 20#pythonの中身的には、タプルを作って展開している、ということになる。
print(x, y)

min, max = 0, 100
print(min, max)
#↑のような定義は長いと冗長的になるので、良くない・

#アンパッキングを利用しえて数字の入れ替えができる。
a = 100
b = 200
print(a, b)#100, 200
a, b = b, a#入れ換えている
print(a, b)

#タプルの使い所
#ユーザーが選択肢の中から二つ選ぶ
chose_from_two = ('A', 'B', 'C')

answer = []#answerはリストで定義
answer.append('A')
answer.append('C')

print(chose_from_two)#('A', 'B', 'C')
print(answer)#['A', 'C']

#良くないパターン

bad_chose_from_two = ['A', 'B', 'C']#タプルではなくリストで定義

bad_answer = []#answerはリストで定義
bad_chose_from_two.append('A')#間違って開発者が選択肢に答えを入れてしまう。
bad_chose_from_two.append('C')#タプルにappendは使えないので、バグが発生する。

print(chose_from_two)#['A', 'B', 'C', 'A', 'C']
print(answer)#['A', 'C']
#タプルで宣言した中身は書き換えられないので、バグの発生率を抑えることができる。

