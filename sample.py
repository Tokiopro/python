# リスト型=配列
l = [1, 20, 30, 40, 5, 8, 90]

print(l[0])
# 後ろから取ってくることもできる
list = l[-1]
# 2番目から5番目まで(2,3,4)
print(l[2:5])
# 省略できる [:2]0から2番目まで、[2:]2番目から最後まで
# [::2]ふたつ飛ばしで取得、[::-1]後ろから取得

# リストの操作
# 指定して代入できる。
l[0] = 'x'
l[2:5] = ['c', 'd', 'e']

#空の配列を入れたい場合は、[]を代入するだけ。全部をからにする場合は[:] = []
#append=一番最後に値を追加
#insert(要素数、値)で位代入できる
#pop＝取り出して削除
#del=存在こと削除してしまう
#remove=指定した値を消すことができるremove('x')

#配列を結合するとき a += b
#a.extend(b)というメソッドでも結合できる。

r = [1, 2, 3, 4, 5, 6, 7, 8, 9, 3]
#index(3)だと、インデックス番号を探してくれる。
print(r.index(3,3))
#カンマをつけると、一つ目の数字のインデックス番号移行を検索
#count=要素数を数える

#配列に5は存在するか？
if 5 in r:
    print('exist')
    
#並び替え、reverse=Trueを入れると逆順
r.sort()
r.sort(reverse=True)
#もう一度reverseすると元に戻る
r.reverse()
print(r)

#文字を単語ごとに要素分けして配列に入れる場合
s = 'My name is Mike.'
to_split = s.split('!!')#空白を入れて、要素わけする。存在しない文字列にした場合と全てを一つの要素として配列にしてしまう。
#空白はバリューエラー
print(to_split)

#joinは代入して結合する
x = ' a '.join(to_split)
print(x)

i = [1,2,3]
j = i
j[0] = 100
#この場合、iも入れ替わってしまう。
#なぜ？メモリーに保存してるiのアドレスをjに入れているから（参照渡し）
#リストやディクショナリーは参照渡し、数値などは値わたしなのでコピーする必要はない。

#どう避けるか？コピーを使う。
j = i.copy()
#または[:]を使っても同じことができる。可読性を考慮するとコピーを使った方が良い。

#リストの使い所
#乗客が乗降するタクシー、5人までしか乗れない
seat = []
min = 0
max = 5
check = min <= len(seat) < max
#一人のる
seat.append('p')
print(seat)
print(check)
#一人降りる
seat.pop(0)

#要素数が変動するものに対して論理和などでチェックするという使い方・

#タプル型 ()の中にある配列
t = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
#リストとタプルの違いは？
#リストはブランケットの鉤括弧[]
#タプルはパレンティスの丸括弧()
#タプルはt[0] = 100 などの代入ができない
#使用する場面、ケースとしては、値を代入したら後から変更されたくない、読み込み専用とするときに使われる場合が多い。

#indexなどの読み込み操作などはできる。t[0] = [1]のような代入はできない
#help(tuple)でみるとわかる。
t.index(1)

#タプルは,をつけた時点でタプルになる。t, でもタプルになる。バグの原因になりやすい。
#t=(1)とするとintegerになってしまう。t = (1,)としなければならない。（一つだけのタプルはあまりない）
#タプルにネストしたリストを入れることはできる。
t2 = ([1, 2, 3], [4, 5, 6])

#タプル同士は足すことができる。
new_tuple = (1, 2, 3) + (4, 5, 6)

#タプルのアンパッキング
num_tuple = (10, 20)
print(num_tuple)#(10, 20)

x, y = num_tuple#カンマで区切れば、アンパッキングできる
print(x, y)#10,20

x, y = 10, 20#pythonの中身的には、タプルを作って展開している、ということになる。
print(x, y)

min, max = 0, 100
print(min, max)
#↑のような定義は長いと冗長的になるので、良くない・

#アンパッキングを利用しえて数字の入れ替えができる。
a = 100
b = 200
print(a, b)#100, 200
a, b = b, a#入れ換えている
print(a, b)

#タプルの使い所
#ユーザーが選択肢の中から二つ選ぶ
chose_from_two = ('A', 'B', 'C')

answer = []#answerはリストで定義
answer.append('A')
answer.append('C')

print(chose_from_two)#('A', 'B', 'C')
print(answer)#['A', 'C']

#良くないパターン

bad_chose_from_two = ['A', 'B', 'C']#タプルではなくリストで定義

bad_answer = []#answerはリストで定義
bad_chose_from_two.append('A')#間違って開発者が選択肢に答えを入れてしまう。
bad_chose_from_two.append('C')#タプルにappendは使えないので、バグが発生する。

print(chose_from_two)#['A', 'B', 'C', 'A', 'C']
print(answer)#['A', 'C']
#タプルで宣言した中身は書き換えられないので、バグの発生率を抑えることができる。]

#辞書型（ディクショナリー、dict)
d = { 'x': 10, 'y': 20 }
d['x']#keyを鉤括弧で指定すると値にアクセスできる
#→10
d['x'] = 100#xに値を代入
d['z'] = 200#新しく追加
d[1] = 10000#追加

#他の辞書の作り方
dict(a=10, b=20)
#tupleを使う,配列の中に辞書を作っている。
dict([('a', 10), ('b', 20)])

#辞書型のメソッド

test = {'x': 10, 'y': 20}
# help(test)

test.keys()
test.values()

#他の辞書型で辞書をアップデートさせたいとき
test2 = {'x': 1000, 'j': 500}
#updateメソッドを使う
test.update(test2)
print(test)
#{'x': 1000, 'y': 20, 'j': 500}

#辞書型の中身はdict['key']という方法もあるが、getメソッドを使ってアクセスすることもできる。
#何が違うか？
#dict['key']で存在しないものにアクセスするとエラーが発生する。
#getメソッドで存在しないものにアクセスするとNoneTypeというものが返してくる。
print(test.get('z'))#None
#取り除くメソッドpop
test.pop('x')#{'y': 20, 'j': 500}

#削除するメソッドdel
del test['y']#yを削除
print(test)#{'j': 500}
#変数自体を消してしまうとエラーが起きてしまう。
#del test#NameError: name 'test' is not defined
#辞書を空にするには？

test.clear()#{}
print(test)

#特定のキーが入っているかどうか？
test = {'a': 100, 'b': 200 }
print(test)
print('a' in test)#testという辞書の中にaというキーは入っているか？
#Trueと返ってくる。ない場合はFalse

#辞書のコピー
#リストと同様、下の場合は参照渡しになってしまい、xの'a'の値も変更されてしまう。
x = {'a': 1 }
y = x
y['a'] = 1000
print(x)
print(y)
#{'a': 1000}
#{'a': 1000}

#コピーメソッドを使う
x = {'a': 1}
y = x.copy()
y['a'] = 1000
print(x)
print(y)
#{'a': 1}
#{'a': 1000}

#辞書型の使い所
#果物を売るオンラインサイト

fluits = {
    'apple': 100,
    'banana': 200,
    'orange': 300,
}

print(fluits['apple'])

#リストでも定義できるが、リストは検索に時間がかかる。
#appleを取り出したい時、一番最初からリストのどこにappleがあるか探しに行く処理を書かなければならない。
l= [
    ['apple', 100],
    ['banana', 200],
    ['orange', 300],
]

#辞書型はハッシュテーブルというものを用いているので、検索スピードが早い。プログラムの中身的な違い。

#集合型s
a = {1, 2, 2, 3, 4, 4, 4, 5, 6}
#<class 'set'>
b = {2, 3, 3, 6, 7}

#集合の論理和
print(a - b)#{1, 4, 5}
print(b - a)#{7}
print(a & b)#{2, 3, 6}
#aまたはb
print(a | b)#{1, 2, 3, 4, 5, 6, 7}
#aの排他のb　どちらかにあるが重複はしていない
print(a ^ b)#{1, 4, 5, 7}


